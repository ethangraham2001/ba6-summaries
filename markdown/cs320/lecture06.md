# Lecture 06: Types

> Well-typed programs do not get stuck.

Types can predict whether a particular program will get stuck *(go wrong)* when
executed by some machine. 

Rice's theorem states that non-trivial semantic properties are undecidable;
we use types as a conservative approximation of run-time values to verify some
semantic properties, preventing well-typed programs from getting stuck at 
runtime.

We aim at soundness, not completeness.

## Lambda Calculus with Constants and Types

A **typing judgement** has the form

$$
\Gamma \vdash e : \tau
$$

Which is saying *given $\Gamma$ a typing environment, $e$ has type $\tau$*.

## Type Safety

### Soundness Theorem

If $\vdash e : \tau$ and $e \rightarrow_\lambda^\star e'$ and there is no $e''$
such that $e' \rightarrow_\lambda e''$, then $e'$ is a value.

What this is saying in simpler terms it that

- $e$ is well-typed,
- $e$ reduces to $e'$ in some number $n$ of steps
- $e'$ cannot be reduced any further to some $e''$

Then $e'$ is a value.

### Progress and Preservation

One popular approach for proving type-safety is showing progress and 
preservation

- **Progress:** if $e$ is well-typed, then either $e$ is a value, or we can
reduce $e$ to some $e'$.
- **Preservation:** if $e$ has type $\tau$ and reduces to $e'$, then $e'$ has
type $\tau$.

## Type Inference

Intuitively consists of gathering constraints on the type of each expression
and using such constraints to make appropriate guesses. Constraints are
generated by visiting the AST

- A type is assigned to each node depending on its shape
- Type information depending on other expressions is represented by fresh type
variables that are eventually substitued via **unification**

### Unification

Given terms $t_1, t_2$, unification is a procedure that succeeds if it can find
a substitution $\sigma$ mapping variables to closed temrs such that 
$t_1\sigma = t_2\sigma$, otherwise it fails.

Unification can be used to propagate type information - for example:

```scala
val a = 5.0 // : Double = 5.0
val b = 2 // : Int = 2

val c = a + b // : Double = 7.0
```

Where unification is used to decide the type of `c`

