# Lecture 04: Parsers

## Formal Grammars

Intuitively, a set of rewriting rules *(aka production rules)*. For instance

- $S \rightarrow Tb$
- $T \rightarrow \varepsilon$
- $T \rightarrow aT$

Rules are composed of terminal and non-terminal symbols, written in lower case
and upper case respectively.

Starting from a start symbol $S$ we can recursively apply rules until obtaining
a word consisting only of terminal symbols. A sequence of rule applications is
called a derivation.

Formally, a formal grammer $G = (\Sigma, \Theta, S, P)$ where

- $\Sigma$ alphabet (a finite set of terminal symbols)
- $\Theta$ set of non-terminal symbols s.t. $\Sigma \cap \Theta = \emptyset$
- $S \in \Theta$ denotes a start symbol
- $P$ is a finite set of production rules $x \rightarrow y$

The language generated by grammar $G$ is written $L(G)$

## Chomsky Hierarchy

> The Chomsky hierarchy (infrequently referred to as the Chomsky–Schützenberger 
> hierarchy) in the fields of formal language theory, computer science, and 
> linguistics, is a containment hierarchy of classes of formal grammars. A 
> formal grammar describes how to form strings from a language's vocabulary 
> (or alphabet) that are valid according to the language's syntax. Linguist 
> Noam Chomsky theorized that four different classes of formal grammars existed 
> that could generate increasingly complex languages. Each class can also 
> completely generate the language of all inferior classes (set inclusive). 

### Type 0: Unrestricted Grammars

No constraints on the production rules. They generate exactly all languages 
that can be recognized by a Turing machine.

An example would be

$$
L = \lbrace w | w \textit{ describes a terminating Turing machine } \rbrace
$$

Which is an undecidable problem. Thus deciding whether a word $w$ belongs to
$L(G)$ of an unrestricted grammar $G$ is indecidable.

### Type 1: Context-sensitive Grammars

Productions are restricted to either of the following forms

- $T \rightarrow \varepsilon$ 
- $xTz \rightarrow xyz$ with $x,y,z$ strings of terminal symbols, and $y$ 
non-empty

Intuitively, the second case only allows us to replace $T$ when it is 
surrounded by some context. Deciding whether $L(G) = \emptyset$ for an arbitrary
context-sensitive grammar $G$ is undecidable.

Think of XML, where a starting tag `<a>` needs to be matched by a `<\a>` for
whatever is contained between them to be considered valid. Thus it is indeed
context sensitive.

### Type 2: Context-free Grammars

Production rules are restricted to

- $T \rightarrow y$ where $y$ is a non-empty word of terminal symbols.

Given two context-free grammars $G_1, G_2$ deciding whether $L(G_1) = L(G_2)$
is undecidable.

### Type 3: Regular Grammars

Productions rules limited to the following forms

- $T \rightarrow \varepsilon$
- $T \rightarrow \varepsilon$ 
- $T \rightarrow sU$

These languages are recognizable by finite state automaton.

## Regular Expression (Regex)

Character string describing a regular language. They can be parsed very 
efficiently. Formally, given an alphabet $\Sigma$, regexes are recursively 
defined as followed:

- $\emptyset$ is a regex s.t. $L(\emptyset) = \emptyset$
- $\varepsilon$ is a regex s.t. $L(\varepsilon) = \lbrace \varepsilon \rbrace$
- if $s \in \Sigma$ then $s$ is a regex s.t. $L(s) = \lbrace s \rbrace$
- if $r_1, r_2$ are regexes, then $r_1 | r_2$ is a regex s.t.
$L(r_1|r_2) = L(r_1) \cup L(r_2)$
- if $r_1, r_2$ are regexes, then $r_1 r_2$ is a regex s.t.
$L(r_1|r_2) = L(r_1) \cdot L(r_2)$
- if $r$ is a regex, then $r^\star$ is a regex s.t. $L(r^\star) = L(r)^\star$

### Examples

- $abc$ recognizes $\lbrace abc \rbrace$
- $a^\star b$ recognizes $\lbrace a, ab, aab, aaab, \dots \rbrace$
- $(ab)^\star | c^\star$ recognizes 
$\lbrace \varepsilon, ab abab, ababab, \dots c, cc, ccc, \dots \rbrace$
- $((ab)|c)^\star$ recognizes 
$\lbrace \varepsilon ab, c, abab, abc, cab, cc, \dots \rbrace$

# Re-Chomsky Hierarchy

Type 3 and type 2 languages are desirable because they can be parsed 
efficiently in $O(n)$ and $O(n^3)$ respectively in general.

In many cases *(for example indendation in python/Scala)* we end up with type-1
context-sensitive languages. This becomes quite complex.

## Parse Trees

We can represent the result of a derivation as a tree whose branch nodes are
non-terminal symbols, and whose leaf nodes are terminal symbols.

Grammars can be ambiguous, i.e. they are capable of generating different parse
trees from the same input $\rightarrow$ parse forests, eventually deciding on
one of them. In general, disambiguation is preferable.

Determining whether a grammar is ambiguous is undecidable, but there exist
semi-decidable algorithms for context-free grammars. Some languages are
inherently ambiguous, and there exist parsing algorithms designed to handle
such cases.

## Handling Infinite Recursion

We can transform production rules to eliminate left or right recursion.

- Add a new non-terminal symbol $S'$ at the end (left recursive) or start
(rigth recursive) of non-recursive production rules.
- The production rules for $S'$ swap the position of the recursion.

